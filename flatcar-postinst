#!/bin/bash
# Copyright (c) 2014 The CoreOS Authors.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

set -euo pipefail
umask 0022

OEM_MNT="/usr/share/oem"

INSTALL_MNT=$(dirname "$0")
INSTALL_DEV="$1"
INSTALL_KERNEL=""

for arg in "$@"; do
    case "${arg}" in
        KERNEL=*) INSTALL_KERNEL="${arg#KERNEL=}" ;;
    esac
done

# Figure out if the slot id is A or B
INSTALL_LABEL=$(blkid -o value -s PARTLABEL "${INSTALL_DEV}")
case "${INSTALL_LABEL}" in
    ROOT-A|USR-A)
        SLOT=A;;
    ROOT-B|USR-B)
        SLOT=B;;
    *)
        echo "Unknown LABEL ${INSTALL_LABEL}" >&2
        exit 1
esac

# Find the ESP partition and mount it if needed
ESP_PARTTYPE="c12a7328-f81f-11d2-ba4b-00a0c93ec93b"
ESP_MNT=

declare -a DEV_LIST
mapfile DEV_LIST < <(lsblk -P -o NAME,PARTTYPE,MOUNTPOINT)

for dev_info in "${DEV_LIST[@]}"; do
    eval "$dev_info"

    if [[ "${PARTTYPE}" != "${ESP_PARTTYPE}" ]]; then
        continue
    fi

    if [[ -n "${MOUNTPOINT}" ]]; then
        ESP_MNT="${MOUNTPOINT}"
    else
        ESP_MNT="$(mktemp -d /tmp/postinst_esp.XXXXXXXXXX)"
        mount "/dev/${NAME}" "${ESP_MNT}"
        trap "umount '${ESP_MNT}' && rmdir '${ESP_MNT}'" EXIT
    fi

    break
done

if [[ -z "${ESP_MNT}" ]]; then
    echo "Failed to find ESP partition!" >&2
    exit 1
fi

if [[ ! -d "${ESP_MNT}" ]]; then
    echo "ESP partition mount point (${ESP_MNT}) is not a directory!" >&2
    exit 1
fi

# Update bootloaders from CoreOS <= 522.x.x
if grep -q cros_legacy /proc/cmdline; then
    # Update kernel and bootloader configs
    mkdir -p "${ESP_MNT}"{/syslinux,/boot/grub}
    cp -v "${INSTALL_MNT}/boot/vmlinuz" \
        "${ESP_MNT}/syslinux/vmlinuz.${SLOT}"
    cp -v "${INSTALL_MNT}/boot/syslinux/root.${SLOT}.cfg" \
        "${ESP_MNT}/syslinux/root.${SLOT}.cfg"

    # For Xen's pvgrub
    cp -v "${INSTALL_MNT}/boot/grub/menu.lst.${SLOT}" \
        "${ESP_MNT}/boot/grub/menu.lst"

    # For systems that have disabled boot_kernel and kexec
    if ! grep -q boot_kernel "${ESP_MNT}/syslinux/default.cfg"; then
        cp -v "${INSTALL_MNT}/boot/syslinux/default.cfg.${SLOT}" \
            "${ESP_MNT}/syslinux/default.cfg"
    fi
elif [[ -z "${INSTALL_KERNEL}" ]]; then
    # not a legacy system but update_engine didn't handle the kernel.
    # kernel names are in lower case, ${SLOT,,} converts the slot name
    if [ -e "${ESP_MNT}/coreos/vmlinuz-a" ] || [ -e "${ESP_MNT}/coreos/vmlinuz-b" ]; then
        cp -v "${INSTALL_MNT}/boot/vmlinuz" \
           "${ESP_MNT}/coreos/vmlinuz-${SLOT,,}"
    else
        cp -v "${INSTALL_MNT}/boot/vmlinuz" \
           "${ESP_MNT}/flatcar/vmlinuz-${SLOT,,}"
    fi
fi

# If the OEM provides a hook, call it
if [[ -x "${OEM_MNT}/bin/oem-postinst" ]]; then
    "${OEM_MNT}/bin/oem-postinst" "${SLOT}" "${INSTALL_MNT}"
fi

# locksmith 0.1.5 is broken, restart it lots to work around the issue
if systemctl is-active --quiet locksmithd.service && \
    locksmithctl help | grep -A1 '^VERSION:' | grep -q '0.1.5$';
then
    echo "Broken locksmith 0.1.5 detected, installing workaround timer."
    # In one minute start restarting locksmithd every 5 minutes.
    cat >/run/systemd/system/locksmithd-kicker.timer <<EOF
[Timer]
OnActiveSec=1min
OnUnitActiveSec=5min
EOF
    cat >/run/systemd/system/locksmithd-kicker.service <<EOF
[Service]
Type=oneshot
ExecStart=/usr/bin/systemctl try-restart --no-block locksmithd.service
EOF
    systemctl start --no-block locksmithd-kicker.timer
fi

# Azure's agent erroneously looks at the distribution name instead of its ID.
# This prevents us from renaming the OS from "Flatcar". This patches platform.py
# to always return "Flatcar" as the distribution name.
PLATFORM_PATH="/usr/share/oem/python/lib64/python2.7/platform.py"
if [ -e ${PLATFORM_PATH} ]; then
    sum=($(md5sum ${PLATFORM_PATH}))
    if [ ${sum} == "6315addf42c0b07f5f78d119b578e20a" ]; then
        sed --in-place \
            "s%distname = os_release_info\['NAME'\]%distname = \"Flatcar\"%" \
            ${PLATFORM_PATH}
    fi
fi

# Our VMware OEM partition contained a version of vmtoolsd that was vulnerable to 
# CVE-2015-5191 (http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-5191).
# This CVE can be mitigated by setting PrivateTmp=true on the vmtoolsd service file.
# coreos-base/oem-vmware-10.1.5 is the last vulnerable version of the oem ebuild.
# Note: we check in both /etc/oem-release and /usr/share/oem/oem-release
# because pre-ignition Container Linux machines did not set the oem.id cmdline,
# and also wrote oem-release only to /etc
VMTOOLSD_DROPIN=/etc/systemd/system/vmtoolsd.service.d/90-tmpfiles-cve-2015-4191.conf
if [ ! -e $VMTOOLSD_DROPIN ] && grep --quiet --no-messages "^ID=vmware$" /etc/oem-release /usr/share/oem/oem-release; then
    mkdir -p /etc/systemd/system/vmtoolsd.service.d/
    cat >$VMTOOLSD_DROPIN <<EOF
# This file is automatically added during updates to mitigate CVE-2015-5191.
# See http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-5191 for more info
# on the CVE.
# If you believe this file causes any issue, please report it as a bug to
# Flatcar.
[Service]
PrivateTmp=true
EOF
fi

# Gather metadata about upcoming OS image.
# shellcheck source=/dev/null
source "${INSTALL_MNT}/lib/os-release"
NEXT_VERSION_ID=${VERSION_ID}

# shellcheck source=/dev/null
source /usr/lib/os-release

tee_journal() {
    tee >(systemd-cat -t coreos-postinst)
}

# Keep old nodes on cgroup v1
if [[ "${BUILD_ID}" != "dev-"* ]]; then
    if [ "${VERSION_ID%%.*}" -lt 2956 ]; then

        # if there is an explicit setting, don't touch it. Otherwise...
        if ! grep -q systemd.unified_cgroup_hierarchy "${OEM_MNT}/grub.cfg" 2>/dev/null; then
            cat >>"${OEM_MNT}/grub.cfg" <<EOF

# Automatically added during update from ${VERSION_ID} to ${NEXT_VERSION_ID}
# Flatcar has migrated to cgroup v2. Your node has been kept on cgroup v1.
# Migrate at your own convenience by changing the value to '=1', or remove this
# line if you don't need to switch back ('systemd.legacy_systemd_cgroup_controller' only has effect for '=0').
# For more details visit:
# https://kinvolk.io/docs/flatcar-container-linux/latest/container-runtimes/switching-to-unified-cgroups
set linux_append="\$linux_append systemd.unified_cgroup_hierarchy=0 systemd.legacy_systemd_cgroup_controller"
EOF
        fi

	if ( systemctl show -p ExecStart containerd | \
             grep -qF '/usr/bin/env PATH=${TORCX_BINDIR}:${PATH} ${TORCX_BINDIR}/containerd --config ${TORCX_UNPACKDIR}${TORCX_IMAGEDIR}${CONTAINERD_CONFIG}' ) && \
	   ( systemctl show -p Environment containerd | \
	     grep -qF 'CONTAINERD_CONFIG=/usr/share/containerd/config.toml' ); then
            mkdir -p /etc/systemd/system/containerd.service.d/
	    cat >/etc/systemd/system/containerd.service.d/10-use-cgroupfs.conf <<EOF
# Automatically created during update from ${VERSION_ID} to ${NEXT_VERSION_ID}
# Flatcar has migrated to cgroup v2. Your node has been kept on cgroup v1.
# For more details visit:
# https://kinvolk.io/docs/flatcar-container-linux/latest/container-runtimes/switching-to-unified-cgroups
[Service]
Environment=CONTAINERD_CONFIG=/usr/share/containerd/config-cgroupfs.toml
EOF
	fi
    fi
fi


# use the cgpt binary from the image to ensure compatibility
CGPT=
for bindir in bin/old_bins bin sbin; do
    if [[ -x "${INSTALL_MNT}/${bindir}/cgpt" ]]; then
        CGPT="${INSTALL_MNT}/${bindir}/cgpt"
        break
    fi
done
if [[ -z "${CGPT}" ]]; then
    echo "Failed to locate the cgpt binary in ${INSTALL_MNT}" >&2
    exit 1
fi

call_cgpt() {
    "${LDSO}" --library-path "${LIBS}" "${CGPT}" "$@"
}

# locate the dynamic linker
LDSO=

# While glibc 2.33 has /lib64/ld-2.33.so, glibc 2.34 does not have
# that, but only /lib64/ld-linux-x86-64.so.2. So we should also check
# ld-linux-* as well.
#
# glibc 2.35 installs a symlink to the dynamic linker under
# /usr/bin/ld.so. Check this one too.
#
# Since we derive library path from the linker path, make sure we are
# dealing with the actual executable, not with a symlink. We do it by
# using realpath on the found file.
for l in "${INSTALL_MNT}"/{,usr/}bin/ld.so "${INSTALL_MNT}"/lib*/ld-2.??.so "${INSTALL_MNT}"/lib*/ld-linux-*.so.?; do
    if [[ -x "$l" ]]; then
        LDSO=$(realpath "$l")
        break
    fi
done
if [[ -z "${LDSO}" ]]; then
    echo "Failed to locate ld.so in ${INSTALL_MNT}" >&2
    exit 1
fi
LIBS="${LDSO%/*}"

# Use torcx binary from next-OS image to ensure compatibility
TORCX_BIN=""
for bindir in bin/old_bins bin sbin lib/coreos; do
    if [[ -x "${INSTALL_MNT}/${bindir}/torcx" ]]; then
        TORCX_BIN="${INSTALL_MNT}/${bindir}/torcx"
        break
    fi
done
if [[ -z "${TORCX_BIN}" ]]; then
    echo "Failed to locate torcx binary in ${INSTALL_MNT}" 2>&1 | tee_journal
    exit 1
fi

call_torcx() {
    "${TORCX_BIN}" "$@" 2>&1 | tee_journal
}

# Check if torcx requires any additional addon available on a remote.
: "${TORCX_CHECK_REMOTE_ONLY:="true"}"
TORCX_USR_MOUNTPOINT="${INSTALL_MNT}"
if [[ -e /etc/torcx/next-profile ]] && [[ -n "${TORCX_BIN}" ]] ; then
    export -- TORCX_USR_MOUNTPOINT
    if ! call_torcx profile check --remote-only="${TORCX_CHECK_REMOTE_ONLY}" --os-release="${NEXT_VERSION_ID}" ; then
        echo "Populating local torcx store with remote images. This may take some time." | tee_journal
        call_torcx profile populate --os-release="${NEXT_VERSION_ID}"
        call_torcx profile check --remote-only="${TORCX_CHECK_REMOTE_ONLY}" --os-release="${NEXT_VERSION_ID}"
        call_torcx image clear-versioned -k "${VERSION_ID}"  -k "${NEXT_VERSION_ID}"
    fi
fi

# Mark the new install with one try and the highest priority
call_cgpt repair "${INSTALL_DEV}"
call_cgpt add -S0 -T1 "${INSTALL_DEV}"
call_cgpt prioritize "${INSTALL_DEV}"
call_cgpt show "${INSTALL_DEV}"

cat "${INSTALL_MNT}/share/flatcar/release"
echo "Setup ${INSTALL_LABEL} (${INSTALL_DEV}) for next boot."

# Create the Ubuntu-compatible /run/reboot-required flag file for kured
touch /run/reboot-required
